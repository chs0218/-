1. 행렬다루기

변수 - 2가지 행렬의 값을 가지고 있어야하므로 iFirstMatrix라는 이름의 이차원배열과 iSecondMatrix라는 이름의 이차원배열 두개를 선언하고 그 외에
행렬의 크기의 값을 가지고 있을 정수형 변수 iSize와 명령을 구분해줄 문자형변수 cCommand를 선언했습니다.

랜덤배열 - srand와 rand를 이용해 행렬과 사이즈를 받으면 행렬들에 0이나 1을 랜덤하게 넣어주는 RandomMatrix라는 함수를 구현하였습니다.

키보드입력 - 기본적으로 while문 안에서 계속 돌며 명령을 받게했고 q를 입력받으면 프로그램을 종료하게하였습니다. 받는 명령어가 하나 이상일 경우
제일 앞의 문자를 명령으로 받으며 문자가 아닌경우 다시 입력받습니다.

a - 두 행렬을 더해 iResultMatrix라는 이차원배열에 담아 결과를 출력합니다.
d - 두 행렬을 뺄셈해 iResultMatrix라는 이차원배열에 담아 결과를 출력합니다.
m - 두 행렬를 곱해 iResultMatrix라는 이차원배열에 담아 결과를 출력합니다.
r - 행렬을 for문으로 출력하고 행렬의 크기가 3일 경우 사로스 공식을 이용해 행렬식의 값을 계산하고 출력합니다. 행렬의 크기가 4일경우 첫번째 가로열로 라플라스 전개
를 통해 행렬식을 계산합니다.
t - 두 행렬을 for문으로 전치행렬로 바꾸어 출력하고 그 행렬식의 값을 출력합니다.
h - 행렬의 크기를 가지고 있는 iSize라는 변수를 검사해 크기가 3일경우 iSize를 4로 바꾸어 4X4행렬로 변환하고 4일경우 iSize를 3으로 바꾸어 3X3행렬로
바꿉니다. 4로 바꿀경우 4행 에 0을 4열에 0을 4행 4열에 1을 추가했습니다.
s - 처음에 구현한 RandomMatrix라는 함수를 호출해 랜덤하게 설정합니다.
q - 프로그램을 종료합니다.

2. 파일에서 데이터 읽기

(1) 프로그램이 시작하면 while문 안에서 파일 입력을 입력 받으며 입력을 정상적으로 받았을 경우 str이라는 이름을 가진 문자형배열에 집어넣고 한 줄을 읽을때마다
   iLine이라는 정수형 변수의 값을 증가시켜 줄 수를 받습니다. (한 줄에 최대 80 문자를 받아옵니다.)

(2) 입력받은 str 변수를 검사하여 널값이 나오거나 띄어쓰기가 될 경우 iWord라는 단어의 수를 담고 있는변수의 값을 증가시켜 단어의 수를 셉니다.

(3) 널값이랑 띄어쓰기가 아닐경우 W_MyWord라는 구조체 변수에 문자가 숫자일 경우 bIsNumber라는 bool값을 true로 바꾸어주고
    cWord라는 char형배열에 문자를 저장하고 iNum이라는 단어의 길이를 담은 변수의 값을 증가시킵니다. 이 행동이 끝나면 해당문자를 출력합니다.
    // 이로써 단어들은 전부 W_MyWord라는 구조체배열에 전부 담깁니다.

(4) 단어를 전부 담은 W_MyWord변수를 검사하여 bIsNumber가 true일 경우 숫자단어의 개수 담고있는 iNumberWord의 값을 증가시키고 해당 단어를 출력합니다.

(5) 숫자가 있는 단어의 개수, 숫자가 없는 단어의 개수, 총 단어의 개수를 출력합니다.

3. 문자열 다루기

(1) 프로그램이 시작하면 while문 안에서 파일이름을 입력받으며 그것을 getline을 사용해 string타입 변수에 담아 파일을 열어보고 파일이 열리면 해당 파일의
내용을 getline을 사용해 문자열변수에 한줄에 최대 80자씩 받습니다.

(2) while문에서 계속 돌며 'q'를 입력 받을 때 까지 키보드 명령을 받습니다. 소문자 a~z까지 입력 받고 이를 제외한 문자는 받지않습니다.

d - 임시의 Tmp라는 문자열을 선언해 Tmp 문자열에 파일의 문자열 한줄을 strncpy_s를 통해 복사합니다. 그리고 파일의 문자열을 Tmp의 뒤쪽문자열부터 차례로
복사해 최종적으로 뒤집힌 문장을 만들어냅니다. 이를 파일의 줄 수를 담고있는 iLine이라는 변수만큼 반복해줍니다.

e - e 명령을 이미 한번 받은 상태인지 IsCommandE라는 bool형 타입 변수로 확인하고 
이미 한번 받은 상태일 경우 '*'문자를 찾아내 해당 문자부터 문자의 뒤 두단계 문자열을 받아옵니다(기본적으로 삽입할때 *을 두개씩 삽입했으므로)
명령을 받지 않은 상태일 경우 iNum이라는 몇문자를 지나쳤는지 세는 정수형 변수를 통해 3문자를 지나쳤을때 문장의 맨 뒤에서부터 두칸씩 앞으로 당기고
3문자를 지나친 시점의 곳과 그 다음에 '*'문자를 넣습니다(이때, *문자를 두개 넣었으므로 다음확인하는 문자를 **을 넣은 그 다음으로 하기위해서 j의 값을 하나 증가
시켜주었습니다.)

f - 임시의 Tmp라는 문자열을 선언해 문장을 한문자씩 검사하며 Tmp 문자열에 하나씩 복사하다가 * 이나 띄어쓰기나 널값을 만났을 때 iStart라는 단어가 시작하는 부분에서
부터 iNum이라는 몇 문자를 지났는지 세주는 변수를 이용해 문자를 뒤집고 iStart와 iNum을 초기화해줍니다. 이를 반복해 해당 명령을 구현하였습니다.

g - 바꿀문자를 A~Z, a~z에서 입력받아 OldLetter라는 문자형 변수에넣고 같은 방법으로 새롭게 넣을 문자를 A~Z, a~z에서 입력받아 NewLetter라는 문자형 변수에 넣습니다
( [ \ ] ^ _ ` )도 받긴하지만 특별히 문제가 없을 것 같아서 놔두었습니다. 이후 문장을 for문으로 검사하면서 OldLetter와 동일한 문자를 찾으면 NewLetter로 바꾸는 행동을
반복합니다.

h - 임시의 Tmp라는 문자열을 선언해 맨앞문자랑 맨뒤문자, 맨앞에서 두번째문자랑 맨뒤에서 두번째문자 ⋅⋅⋅ 을 반복하며 문자가 같을경우 Tmp에 넣어두고 문자의 길이를 세줄
iNum이라는 정수형 변수를 1 증가시킵니다. 문자가 다르면 iNum이 0일경우 0을 문장뒤에 출력하고 아닐경우 문장 뒤에 반복된 문자를 Tmp를 사용해 출력해줍니다.

q - while문을 빠져나와 프로그램을 종료합니다.

4. 사각형과 직선간의 충돌 체크

먼저 저는 이 프로그램에 Point라는 x 좌표와 y 좌표를 가지고 있는 구조체를 만들어 사용했습니다.
Point 구조체로 사각형 좌표를 저장하고 있을 P_Rect라는 구조체 배열과 P_Line이라는 구조체 배열을 선언했습니다.
프로그램이 시작하면 전 각 좌표에 x 는 0~800 사이의 수를 y에는 0~600 사이의 수를 srand와 rand를 사용해 무작위로 넣고
차후 계산하기 편하도록 P_Rect[0]에 좌표상으로 더 왼쪽 좌표를 P_Rect[1]에 좌표상으로 더 오른쪽 좌표를 넣어주고 P_Line 또한 해당 작업을 해주었습니다.
그리고 랜덤하게 배정된 좌표를 출력해주고 while문 안에서 키보드 입력 반복해서 받습니다.

w,a,s,d - 사각형을 각 방향으로 50씩 좌표를 이동시켜줍니다.
i,j,k,l - 직선을 각 방향으로 50씩 좌표를 이동시켜줍니다.

범위를 벗어날 경우 "옮길 수 없습니다." 라는 메세지가 출력되고 좌표가 변하지 않습니다.

사각형과 선분의 충돌체크는 사각형의 4개의 변과 직선을 각각 한번 씩 총 4번 벡터로 교차하는지 판별해 만약 사각형의 변과 직선이 교차하면
충돌하였다는 메세지를 출력했습니다. 
사각형의 한변을 AB, 직선을 CD라고 했을 때 AB에 대한 C의 방향과 AB에대한 D의 방향을 CCW 알고리즘을 통해 반시계 방향인지 시계방향인지 구한 뒤
두 곱셈의 결과가 음수고 CD에 대한 A의 방향과 CD에 대한 B의 방향의 곱셈의 결과가 음수면 교차하는 것으로 판정하였습니다.
만약 곱셈의 결과가 0이라면 두 선분이 평행하다는 의미이므로 예외처리로 두 점의 위치를 비교해 겹치면 충돌하는것으로 판정하였습니다.

5. 저장 리스트 만들기 (구조체 데이터 사용)

점 (x, y, z) 데이터 값을 저장할 Point라는 구조체로 순환 이중 연결 리스트를 만들어 10개의 저장리스트를 만들었습니다. 
보통의 리스트의 시작점의 메모리 주소를가지고 있는 head 변수와 끝점의 메모리 주소를 가진 last, 
정렬된 리스트의 시작점의 메모리 주소를 가지고 있는 arrangehead 변수와 끝점의 메모리 주소를 가진 arrangelast라는 변수를 사용했습니다.

프로그램이 시작하면 보통의 연결리스트와 정렬된 연결리스트 모두에 10개의 메모리를 잡도록 했고 이후 while문을 통해 반복하며 키보드 명령을 받고 수행합니다.
+ : "+ 1 2 3" 이라고 입력하면 보통의 리스트에 점좌표 (1, 2, 3)이 등록되며 리스트상태가 출력됩니다. 등록할 때 math.h에 있는 sqrt와 pow를 사용해 점좌표의 거리를
     계산해서 구조체 내부 변수로 가지고 있습니다. 또한 구조체 내부의 isEmpty라는 변수를 false로 바꾸어 해당 리스트가 비어있지않음을 나타내줬습니다.

- : "-"를 입력하면 구조체 내부의 isEmpty라는 리스트가 비어있는지 여부를 가진 bool형 변수를 true로 바꾸어줌으로서 해당 리스트가 비어있는 상태로 만들어 간단하게 삭제했습니다.

e: "e 1 2 3"이라고 입력하면 먼저 제일 끝(출력상으로 제일 아래)의 리스트가 비었는지 확인하고 비었다면 그 자리에 점 좌표를 넣지만 비어있지 않다면 맨 처음 리스트 부터
   차례로 뒷 리스트를 복사하는 식으로 한칸씩 앞으로 당겨 제일 끝 리스트를 비운뒤에 그 자리에 해당 점 좌표를 넣었습니다.

d: "d"를 입력하면 리스트 제일 끝(출력상으로 제일 아래)의 비어있는지 여부를 나타내는 isEmpty 변수를 true로 바꾸어 비워진 상태로 만들어 삭제하였습니다.

l: "l"을 입력하면 리스트를 처음부터 끝까지 검사하며 isEmpty 변수가 false인 개수를 세서 리스트에 들어있는 점의 개수를 세주었습니다.

c: "c"를 입력하면 리스트 내부 모든 isEmpty 변수가 true로 바뀌면서 모두 비어있는 상태로 만들었습니다.

m: "m"을 입력하면 리스트를 전부 검사해 제일 큰 iLength를 가지고 있는 점 좌표를 변수로 가지고 있다가 검사가 끝나면 마지막에 출력해주는 식으로 최장 거리의 점 좌표를 출력했습니다

m: "n"을 입력하면 리스트를 전부 검사해 제일 작은 iLength를 가지고 있는 점 좌표를 변수로 가지고 있다가 검사가 끝나면 마지막에 출력해주는 식으로 최단 거리의 점 좌표를 출력했습니다

s: "s"를 입력하면 리스트가 iLength의 크기에 따라 정렬되고 isCommandS라는 bool형 변수를 true로 바꾸어 리스트를 조작하는 명령들을 못 받게했습니다.
   s를 입력하면 다시 원래 상태로 돌아옵니다. s 명령 중에는 "l", "m", "n", "s" 명령만 수행할 수 있습니다.

q: "q"를 입력하면 while문을 빠져나오고 프로그램이 종료됩니다.


6. 경로만들기

50X50의 맵은 크기가 너무 커서 콘솔창에 전부 보이지 않으므로 12X12크기의 2차원 평면에서 작업을 하였습니다.
시작점의 위치에 1을 미리 넣어두고 이후에 움직일때마다 iFootprint라는 정수형 변수를 증가시키면서 맵에 숫자들을 넣어주었습니다.
srand와 rand를 사용해 랜덤으로 방향을 이동하게 하였으며 iVec[4]라는 정수형변수를 사용해 상하좌우 한번씩 전환할 수 있도록 프로그래밍하였습니다.
(상 - 하 - 좌 - 우 or 상 - 하 - 우 - 좌 or 상 - 우 - 좌 - 하 ... 이런식으로 한번 방향을 진행할 경우 다른 방향으로도 한번씩 가야 다시 그 방향으로 진행할 수 있도록
프로그래밍하였습니다.)
혹여나 너무 오래동안 도착지에 못 갈 경우를 대비해서 오른쪽과 아래쪽으로 가는 거리는 3이나 4가 나오게, 왼쪽이나 위쪽으로 가는 거리는 1, 2, 3에서 나오도록
설정해 목적지를 향해 가는 거리에 가중치를 넣어 잘 도착할 수 있도록 하였습니다.

r - "r"키를 누르면 경로를 재 설정합니다.
q - "q"키를 누르면 프로그램을 종료합니다.










